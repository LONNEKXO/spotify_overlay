<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Spotify Now Playing Overlay</title>
  <style>
    *,*::before,*::after{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background: transparent; /* STRONA PRZEZROCZYSTA */
      overflow:hidden;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:#e9ecff;
    }

    :root{
      --card-bg: rgba(12,14,30,.88);   /* widget NIE jest przezroczysty */
      --stroke: rgba(97,103,170,.35);
      --pink:#ff5aa6;
      --mauve:#b06cff;
      --radius: 22px;
    }

    /* pozycja overlay */
    .wrap{
      position:fixed;
      left:42px;
      bottom:42px;
      z-index:10;
      transition: opacity .35s ease, transform .35s ease;
      opacity: 0;
      transform: translateY(10px) scale(.98);
      pointer-events:none;
    }
    .wrap.visible{
      opacity:1;
      transform: translateY(0) scale(1);
      pointer-events:auto;
    }

    .card{
      display:inline-flex;
      align-items:center;
      gap:12px;
      padding:10px 14px;
      border-radius:999px;
      background: var(--card-bg);
      border:1px solid var(--stroke);
      box-shadow: 0 18px 45px rgba(0,0,0,.55);
      position:relative;
      overflow:hidden;
      transform: translateZ(0);
      will-change: width;
      transition: width .22s ease, transform .22s ease, opacity .22s ease;
    }

    .card::before{
      content:"";
      position:absolute; inset:-1px;
      background:
        radial-gradient(260px 160px at 0% 0%, rgba(255,90,166,.25), transparent 60%),
        radial-gradient(260px 160px at 100% 100%, rgba(176,108,255,.18), transparent 60%);
      pointer-events:none;
      opacity:.9;
    }

    /* okładka */
    .cover{
      width:54px; height:54px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      overflow:hidden;
      flex:0 0 auto;
      position:relative;
      z-index:1;
      background: rgba(255,255,255,.06);
      box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    .cover img{
      width:100%; height:100%;
      object-fit:cover;
      display:block;
    }

    /* kręcąca się płyta */
    .vinyl{
      width:54px; height:54px;
      flex:0 0 auto;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      position:relative;
      z-index:1;
      background:
        radial-gradient(circle at 50% 50%,
          rgba(255,255,255,.65) 0 2px,
          rgba(0,0,0,.0) 2px 7px,
          rgba(255,255,255,.16) 7px 8px,
          rgba(0,0,0,.0) 8px 12px,
          rgba(255,255,255,.14) 12px 13px,
          rgba(0,0,0,.0) 13px 18px,
          rgba(255,255,255,.10) 18px 19px,
          rgba(0,0,0,.0) 19px 100%
        ),
        radial-gradient(circle at 30% 30%, rgba(255,90,166,.20), transparent 55%),
        radial-gradient(circle at 70% 70%, rgba(176,108,255,.18), transparent 55%),
        rgba(0,0,0,.28);
      box-shadow:0 10px 30px rgba(0,0,0,.35);
      transform-origin: 50% 50%;
    }
    .vinyl::after{
      content:"";
      position:absolute; inset:6px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.08);
      opacity:.8;
    }
    .spin{ animation: spin 2.2s linear infinite; }
    @keyframes spin{ to{ transform: rotate(360deg); } }

    .meta{
      min-width:0;
      display:flex;
      flex-direction:column;
      gap:4px;
      z-index:1;
      position:relative;
    }

    /* UWAGA: nie ucinasz “na siłę”; karta rośnie, a dopiero jak dojdzie do max szerokości okna to da ellipsis */
    .artist{
      font-size:13px;
      font-weight:900;
      letter-spacing:.08em;
      text-transform:uppercase;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      text-shadow:0 0 14px rgba(176,108,255,.35);
    }
    .track{
      font-size:12px;
      font-weight:800;
      letter-spacing:.06em;
      text-transform:uppercase;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      color:#ffe6f6;
      text-shadow:0 0 14px rgba(255,90,166,.30);
    }

    /* progress row */
    .progressRow{
      display:flex;
      align-items:center;
      gap:10px;
      margin-top:2px;
    }

    .time{
      font-size:11px;
      font-weight:800;
      letter-spacing:.08em;
      opacity:.78;
      color:#b8c0ff;
      width:48px;
      text-align:center;
      flex:0 0 auto;
      user-select:none;
    }

    .bar{
      position:relative;
      height:8px;
      flex:1 1 auto;
      min-width:120px;
      border-radius:999px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      box-shadow: inset 0 0 18px rgba(0,0,0,.35);
    }

    .barFill{
      height:100%;
      width:0%;
      border-radius:999px;
      background: linear-gradient(90deg, rgba(255,90,166,.95), rgba(176,108,255,.85));
      box-shadow: 0 0 18px rgba(255,90,166,.25);
      transition: width .15s linear;
    }

    /* responsive */
    @media (max-width:780px){
      .wrap{ left:18px; bottom:18px; }
      .card{ border-radius:22px; }
    }
  </style>
</head>

<body>
  <div class="wrap" id="wrap">
    <div id="card" class="card">
      <div class="vinyl" id="vinyl"></div>
      <div class="cover">
        <img id="coverImg" alt="Okładka utworu" />
      </div>

      <div class="meta">
        <div id="artist" class="artist">Spotify</div>
        <div id="track" class="track">Łączenie…</div>

        <div class="progressRow">
          <div id="tLeft" class="time">0:00</div>
          <div class="bar"><div id="barFill" class="barFill"></div></div>
          <div id="tRight" class="time">0:00</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /**********************
     * USTAW:
     **********************/
    const SPOTIFY_CLIENT_ID = "0ed7689f271f4ba0afde04674e676e71";
    const REDIRECT_URI = "https://lonnekxo.github.io/spotify_overlay/"; // 1:1 jak w Spotify Dev
    const SCOPES = [
      "user-read-currently-playing",
      "user-read-playback-state"
    ].join(" ");

    /**********************
     * UI
     **********************/
    const wrap = document.getElementById("wrap");
    const card = document.getElementById("card");
    const vinyl = document.getElementById("vinyl");
    const coverImg = document.getElementById("coverImg");
    const artistEl = document.getElementById("artist");
    const trackEl = document.getElementById("track");
    const tLeft = document.getElementById("tLeft");
    const tRight = document.getElementById("tRight");
    const barFill = document.getElementById("barFill");

    function showHUD(){ wrap.classList.add("visible"); }
    function hideHUD(){ wrap.classList.remove("visible"); }

    function formatTime(ms){
      const s = Math.max(0, Math.floor(ms / 1000));
      const m = Math.floor(s / 60);
      const r = s % 60;
      return `${m}:${String(r).padStart(2,"0")}`;
    }

    function setIdle(){
      // Jak nic nie gra -> HUD znika
      hideHUD();
      vinyl.classList.remove("spin");
      coverImg.removeAttribute("src");
      artistEl.textContent = "—";
      trackEl.textContent = "—";
      tLeft.textContent = "0:00";
      tRight.textContent = "0:00";
      barFill.style.width = "0%";
      resizeCardToText(); // żeby po powrocie nie było glitchy
    }

    function setPlaying({artist, track, imageUrl, progressMs, durationMs}){
      // Jak gra -> HUD się pokazuje
      showHUD();
      vinyl.classList.add("spin");
      artistEl.textContent = artist || "—";
      trackEl.textContent = track || "—";
      if (imageUrl) coverImg.src = imageUrl;

      // timery
      tLeft.textContent = formatTime(progressMs);
      tRight.textContent = formatTime(durationMs);

      // bar
      const pct = durationMs ? Math.max(0, Math.min(1, progressMs / durationMs)) : 0;
      barFill.style.width = (pct * 100).toFixed(2) + "%";

      resizeCardToText();
    }

    /**********************
     * Auto-resize szerokości karty pod tekst + progress row
     **********************/
    const measureCanvas = document.createElement("canvas");
    const mctx = measureCanvas.getContext("2d");

    function textWidth(text, font){
      mctx.font = font;
      return mctx.measureText(text).width;
    }

    function resizeCardToText(){
      const artistStyle = getComputedStyle(artistEl);
      const trackStyle = getComputedStyle(trackEl);

      const artistFont = `${artistStyle.fontWeight} ${artistStyle.fontSize} ${artistStyle.fontFamily}`;
      const trackFont  = `${trackStyle.fontWeight} ${trackStyle.fontSize} ${trackStyle.fontFamily}`;

      const wA = textWidth(artistEl.textContent || "", artistFont);
      const wT = textWidth(trackEl.textContent || "", trackFont);
      const textW = Math.max(wA, wT);

      // fixed: vinyl + cover + padding + gaps + progress row (czas + czas + minimalny bar)
      const fixedLeft = 54 + 54 + 14*2 + 12*3; // vin + cover + padding + gaps
      const progressMin = 48 + 10 + 120 + 10 + 48; // left time + gap + min bar + gap + right time
      const target = fixedLeft + Math.max(textW, progressMin);

      const minW = 420;
      const maxW = Math.min(window.innerWidth - 60, 1200); // rośnie szerzej niż wcześniej

      const finalW = Math.max(minW, Math.min(maxW, Math.round(target)));
      card.style.width = finalW + "px";
    }

    window.addEventListener("resize", resizeCardToText);

    /**********************
     * PKCE helpers
     **********************/
    function base64UrlEncode(buffer) {
      return btoa(String.fromCharCode(...new Uint8Array(buffer)))
        .replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    }
    async function sha256(plain) {
      const enc = new TextEncoder();
      return await crypto.subtle.digest("SHA-256", enc.encode(plain));
    }
    function randomString(len = 64){
      const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~";
      const arr = new Uint32Array(len);
      crypto.getRandomValues(arr);
      return Array.from(arr, x => chars[x % chars.length]).join("");
    }

    function saveTokens({access_token, refresh_token, expires_in}){
      const expiresAt = Date.now() + (expires_in * 1000) - 10_000;
      localStorage.setItem("sp_access_token", access_token);
      if (refresh_token) localStorage.setItem("sp_refresh_token", refresh_token);
      localStorage.setItem("sp_expires_at", String(expiresAt));
    }
    function clearTokens(){
      localStorage.removeItem("sp_access_token");
      localStorage.removeItem("sp_refresh_token");
      localStorage.removeItem("sp_expires_at");
      localStorage.removeItem("sp_code_verifier");
    }
    function getAccessToken(){ return localStorage.getItem("sp_access_token"); }
    function tokenExpired(){
      const t = Number(localStorage.getItem("sp_expires_at") || "0");
      return !t || Date.now() > t;
    }

    async function refreshAccessToken(){
      const refresh_token = localStorage.getItem("sp_refresh_token");
      if (!refresh_token) return null;

      const body = new URLSearchParams({
        client_id: SPOTIFY_CLIENT_ID,
        grant_type: "refresh_token",
        refresh_token
      });

      const res = await fetch("https://accounts.spotify.com/api/token", {
        method: "POST",
        headers: {"Content-Type":"application/x-www-form-urlencoded"},
        body
      });

      if (!res.ok) return null;

      const data = await res.json();
      saveTokens(data);
      return data.access_token;
    }

    async function startLoginAuto(){
      const code_verifier = randomString(64);
      localStorage.setItem("sp_code_verifier", code_verifier);
      const challenge = base64UrlEncode(await sha256(code_verifier));

      const params = new URLSearchParams({
        response_type: "code",
        client_id: SPOTIFY_CLIENT_ID,
        scope: SCOPES,
        redirect_uri: REDIRECT_URI,
        code_challenge_method: "S256",
        code_challenge: challenge,
      });

      window.location.href = "https://accounts.spotify.com/authorize?" + params.toString();
    }

    async function handleCallbackIfNeeded(){
      const url = new URL(window.location.href);
      const code = url.searchParams.get("code");
      const error = url.searchParams.get("error");

      if (error){
        // jak błąd, HUD chowamy
        setIdle();
        return;
      }
      if (!code) return;

      const code_verifier = localStorage.getItem("sp_code_verifier");
      if (!code_verifier){
        setIdle();
        return;
      }

      const body = new URLSearchParams({
        client_id: SPOTIFY_CLIENT_ID,
        grant_type: "authorization_code",
        code,
        redirect_uri: REDIRECT_URI,
        code_verifier
      });

      const res = await fetch("https://accounts.spotify.com/api/token", {
        method: "POST",
        headers: {"Content-Type":"application/x-www-form-urlencoded"},
        body
      });

      if (!res.ok){
        setIdle();
        return;
      }

      const data = await res.json();
      saveTokens(data);

      url.searchParams.delete("code");
      url.searchParams.delete("state");
      window.history.replaceState({}, document.title, url.toString());
    }

    async function spotifyCurrentlyPlaying(token){
      const res = await fetch("https://api.spotify.com/v1/me/player/currently-playing", {
        headers: { Authorization: "Bearer " + token }
      });

      if (res.status === 204) return { isPlaying:false };
      if (res.status === 401) return { unauthorized:true };
      if (!res.ok) return { error:"HTTP " + res.status };

      const data = await res.json();
      const item = data?.item;
      const isPlaying = Boolean(data?.is_playing && item);

      if (!isPlaying) return { isPlaying:false };

      return {
        isPlaying:true,
        artist: (item.artists || []).map(a=>a.name).join(", "),
        track: item.name || "—",
        imageUrl: item.album?.images?.[0]?.url || "",
        progressMs: data.progress_ms ?? 0,
        durationMs: item.duration_ms ?? 0
      };
    }

    async function ensureToken(){
      let token = getAccessToken();
      if (!token) return null;
      if (tokenExpired()){
        token = await refreshAccessToken();
      }
      return token;
    }

    /**********************
     * Smooth timer (lokalny) + polling API
     **********************/
    let pollTimer = null;
    let smoothTimer = null;

    let curProgress = 0;
    let curDuration = 0;
    let lastSync = 0;

    function stopSmooth(){
      if (smoothTimer) clearInterval(smoothTimer);
      smoothTimer = null;
    }

    function startSmooth(){
      stopSmooth();
      smoothTimer = setInterval(() => {
        if (!wrap.classList.contains("visible")) return;
        if (!curDuration) return;

        const now = Date.now();
        const delta = now - lastSync;
        const progress = Math.min(curDuration, curProgress + delta);

        tLeft.textContent = formatTime(progress);
        const pct = Math.max(0, Math.min(1, progress / curDuration));
        barFill.style.width = (pct * 100).toFixed(2) + "%";

      }, 250);
    }

    async function startPolling(){
      if (pollTimer) clearInterval(pollTimer);

      async function tick(){
        const token = await ensureToken();

        if (!token){
          // auto-connect (1 raz na sesję) żeby nie zrobić redirect loop
          const tried = sessionStorage.getItem("sp_tried_login");
          if (!tried){
            sessionStorage.setItem("sp_tried_login","1");
            setIdle();
            await startLoginAuto();
            return;
          } else {
            setIdle();
            return;
          }
        }

        const result = await spotifyCurrentlyPlaying(token);

        if (result.unauthorized){
          const refreshed = await refreshAccessToken();
          if (!refreshed){
            clearTokens();
            setIdle();
          }
          return;
        }

        if (result.isPlaying){
          // zsynchronizuj smooth timer
          curProgress = result.progressMs;
          curDuration = result.durationMs;
          lastSync = Date.now();
          setPlaying(result);
          startSmooth();
        } else {
          stopSmooth();
          setIdle();
        }
      }

      await tick();
      pollTimer = setInterval(tick, 5000);
    }

    (async function init(){
      // start: schowane
      setIdle();
      resizeCardToText();
      await handleCallbackIfNeeded();
      await startPolling();
    })();
  </script>
</body>
</html>
